-- =============================================
-- CODECOMP - COMPLETE DATABASE INITIALIZATION
-- =============================================
-- This file contains the complete database schema for CodeComp.
-- Run this SQL in your Supabase SQL Editor for initial setup.
-- 
-- Order of execution:
-- 1. Extensions
-- 2. BetterAuth tables (user, session, account, verification, subscription, organization, team, member, invitation)
-- 3. Application tables (competitions, submissions, arenas, etc.)
-- 4. Views
-- 5. Functions
-- 6. Triggers
-- 7. RLS Policies
-- 8. Indexes
-- =============================================

-- =============================================
-- SECTION 1: EXTENSIONS
-- =============================================

CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- =============================================
-- SECTION 2: BETTERAUTH CORE TABLES
-- (Generated by BetterAuth CLI - do not modify manually)
-- =============================================

-- User table (core BetterAuth table)
CREATE TABLE IF NOT EXISTS "user" (
  "id" TEXT NOT NULL PRIMARY KEY,
  "name" TEXT NOT NULL,
  "email" TEXT NOT NULL UNIQUE,
  "emailVerified" BOOLEAN NOT NULL DEFAULT FALSE,
  "image" TEXT,
  "createdAt" TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP NOT NULL,
  "updatedAt" TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP NOT NULL,
  "stripeCustomerId" TEXT
);

-- Session table
CREATE TABLE IF NOT EXISTS "session" (
  "id" TEXT NOT NULL PRIMARY KEY,
  "expiresAt" TIMESTAMPTZ NOT NULL,
  "token" TEXT NOT NULL UNIQUE,
  "createdAt" TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP NOT NULL,
  "updatedAt" TIMESTAMPTZ NOT NULL,
  "ipAddress" TEXT,
  "userAgent" TEXT,
  "userId" TEXT NOT NULL REFERENCES "user" ("id") ON DELETE CASCADE,
  "activeOrganizationId" TEXT,
  "activeTeamId" TEXT
);

-- Account table (OAuth providers)
CREATE TABLE IF NOT EXISTS "account" (
  "id" TEXT NOT NULL PRIMARY KEY,
  "accountId" TEXT NOT NULL,
  "providerId" TEXT NOT NULL,
  "userId" TEXT NOT NULL REFERENCES "user" ("id") ON DELETE CASCADE,
  "accessToken" TEXT,
  "refreshToken" TEXT,
  "idToken" TEXT,
  "accessTokenExpiresAt" TIMESTAMPTZ,
  "refreshTokenExpiresAt" TIMESTAMPTZ,
  "scope" TEXT,
  "password" TEXT,
  "createdAt" TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP NOT NULL,
  "updatedAt" TIMESTAMPTZ NOT NULL
);

-- Verification table (email verification, password reset)
CREATE TABLE IF NOT EXISTS "verification" (
  "id" TEXT NOT NULL PRIMARY KEY,
  "identifier" TEXT NOT NULL,
  "value" TEXT NOT NULL,
  "expiresAt" TIMESTAMPTZ NOT NULL,
  "createdAt" TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP NOT NULL,
  "updatedAt" TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP NOT NULL
);

-- Subscription table (BetterAuth Stripe plugin)
CREATE TABLE IF NOT EXISTS "subscription" (
  "id" TEXT NOT NULL PRIMARY KEY,
  "plan" TEXT NOT NULL,
  "referenceId" TEXT NOT NULL,
  "stripeCustomerId" TEXT,
  "stripeSubscriptionId" TEXT,
  "status" TEXT NOT NULL,
  "periodStart" TIMESTAMPTZ,
  "periodEnd" TIMESTAMPTZ,
  "trialStart" TIMESTAMPTZ,
  "trialEnd" TIMESTAMPTZ,
  "cancelAtPeriodEnd" BOOLEAN,
  "cancelAt" TIMESTAMPTZ,
  "canceledAt" TIMESTAMPTZ,
  "endedAt" TIMESTAMPTZ,
  "seats" INTEGER
);

-- Organization table (BetterAuth Organizations plugin)
CREATE TABLE IF NOT EXISTS "organization" (
  "id" TEXT NOT NULL PRIMARY KEY,
  "stripeCustomerId" TEXT,
  "name" TEXT NOT NULL,
  "slug" TEXT NOT NULL UNIQUE,
  "logo" TEXT,
  "createdAt" TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
  "metadata" TEXT
);

-- Team table (BetterAuth Organizations plugin - teams within organizations)
CREATE TABLE IF NOT EXISTS "team" (
  "id" TEXT NOT NULL PRIMARY KEY,
  "name" TEXT NOT NULL,
  "organizationId" TEXT NOT NULL REFERENCES "organization" ("id") ON DELETE CASCADE,
  "createdAt" TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
  "updatedAt" TIMESTAMPTZ
);

-- Team Member table (BetterAuth Organizations plugin)
CREATE TABLE IF NOT EXISTS "teamMember" (
  "id" TEXT NOT NULL PRIMARY KEY,
  "teamId" TEXT NOT NULL REFERENCES "team" ("id") ON DELETE CASCADE,
  "userId" TEXT NOT NULL REFERENCES "user" ("id") ON DELETE CASCADE,
  "createdAt" TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

-- Organization Member table (BetterAuth Organizations plugin)
CREATE TABLE IF NOT EXISTS "member" (
  "id" TEXT NOT NULL PRIMARY KEY,
  "organizationId" TEXT NOT NULL REFERENCES "organization" ("id") ON DELETE CASCADE,
  "userId" TEXT NOT NULL REFERENCES "user" ("id") ON DELETE CASCADE,
  "role" TEXT NOT NULL,
  "createdAt" TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- Invitation table (BetterAuth Organizations plugin)
CREATE TABLE IF NOT EXISTS "invitation" (
  "id" TEXT NOT NULL PRIMARY KEY,
  "organizationId" TEXT NOT NULL REFERENCES "organization" ("id") ON DELETE CASCADE,
  "email" TEXT NOT NULL,
  "role" TEXT,
  "teamId" TEXT,
  "status" TEXT NOT NULL,
  "expiresAt" TIMESTAMPTZ NOT NULL,
  "createdAt" TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP NOT NULL,
  "inviterId" TEXT NOT NULL REFERENCES "user" ("id") ON DELETE CASCADE
);

-- BetterAuth indexes
CREATE INDEX IF NOT EXISTS "session_userId_idx" ON "session" ("userId");
CREATE INDEX IF NOT EXISTS "account_userId_idx" ON "account" ("userId");
CREATE INDEX IF NOT EXISTS "verification_identifier_idx" ON "verification" ("identifier");
CREATE UNIQUE INDEX IF NOT EXISTS "organization_slug_uidx" ON "organization" ("slug");
CREATE INDEX IF NOT EXISTS "team_organizationId_idx" ON "team" ("organizationId");
CREATE INDEX IF NOT EXISTS "teamMember_teamId_idx" ON "teamMember" ("teamId");
CREATE INDEX IF NOT EXISTS "teamMember_userId_idx" ON "teamMember" ("userId");
CREATE INDEX IF NOT EXISTS "member_organizationId_idx" ON "member" ("organizationId");
CREATE INDEX IF NOT EXISTS "member_userId_idx" ON "member" ("userId");
CREATE INDEX IF NOT EXISTS "invitation_organizationId_idx" ON "invitation" ("organizationId");
CREATE INDEX IF NOT EXISTS "invitation_email_idx" ON "invitation" ("email");

-- =============================================
-- SECTION 3: APPLICATION TABLES
-- =============================================

-- ---------------------------------------------
-- 3.1 COMPETITIONS
-- ---------------------------------------------

CREATE TABLE IF NOT EXISTS competitions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  title VARCHAR(255) NOT NULL,
  description TEXT NOT NULL,
  rules TEXT,
  start_date TIMESTAMP WITH TIME ZONE NOT NULL,
  end_date TIMESTAMP WITH TIME ZONE NOT NULL,
  creator_id VARCHAR(255) NOT NULL,
  allowed_languages TEXT[] DEFAULT ARRAY['python', 'javascript', 'java', 'cpp'],
  status VARCHAR(50) DEFAULT 'draft',
  is_public BOOLEAN DEFAULT TRUE,
  invite_code VARCHAR(20),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS test_cases (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  competition_id UUID NOT NULL REFERENCES competitions(id) ON DELETE CASCADE,
  input TEXT NOT NULL,
  expected_output TEXT NOT NULL,
  points INTEGER DEFAULT 10,
  is_hidden BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS submissions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  competition_id UUID NOT NULL REFERENCES competitions(id) ON DELETE CASCADE,
  user_id VARCHAR(255) NOT NULL,
  code TEXT NOT NULL,
  language VARCHAR(50) NOT NULL,
  status VARCHAR(50) DEFAULT 'pending',
  score INTEGER DEFAULT 0,
  execution_time INTEGER,
  memory_used INTEGER,
  error_message TEXT,
  submitted_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS test_results (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  submission_id UUID NOT NULL REFERENCES submissions(id) ON DELETE CASCADE,
  test_case_id UUID NOT NULL REFERENCES test_cases(id) ON DELETE CASCADE,
  passed BOOLEAN DEFAULT FALSE,
  actual_output TEXT,
  execution_time INTEGER,
  error_message TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS judges (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  competition_id UUID NOT NULL REFERENCES competitions(id) ON DELETE CASCADE,
  user_id VARCHAR(255) NOT NULL,
  role VARCHAR(50) DEFAULT 'judge',
  assigned_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS prizes (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  competition_id UUID NOT NULL REFERENCES competitions(id) ON DELETE CASCADE,
  rank INTEGER NOT NULL,
  title VARCHAR(255) NOT NULL,
  description TEXT,
  value VARCHAR(100),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS competition_templates (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name VARCHAR(255) NOT NULL,
  description TEXT,
  creator_id VARCHAR(255) NOT NULL,
  is_public BOOLEAN DEFAULT FALSE,
  template_title VARCHAR(255),
  template_description TEXT,
  template_rules TEXT,
  allowed_languages TEXT[] DEFAULT ARRAY['python', 'javascript', 'java', 'cpp'],
  default_duration_hours INTEGER DEFAULT 24,
  test_cases JSONB DEFAULT '[]'::jsonb,
  use_count INTEGER DEFAULT 0,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS execution_log (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id VARCHAR(255) NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Competition indexes
CREATE INDEX IF NOT EXISTS idx_competitions_creator ON competitions(creator_id);
CREATE INDEX IF NOT EXISTS idx_competitions_status ON competitions(status);
CREATE INDEX IF NOT EXISTS idx_competitions_is_public ON competitions(is_public);
CREATE INDEX IF NOT EXISTS idx_competitions_invite_code ON competitions(invite_code);
CREATE INDEX IF NOT EXISTS idx_submissions_competition ON submissions(competition_id);
CREATE INDEX IF NOT EXISTS idx_submissions_user ON submissions(user_id);
CREATE INDEX IF NOT EXISTS idx_submissions_status ON submissions(status);
CREATE INDEX IF NOT EXISTS idx_test_cases_competition ON test_cases(competition_id);
CREATE INDEX IF NOT EXISTS idx_judges_competition ON judges(competition_id);
CREATE INDEX IF NOT EXISTS idx_prizes_competition ON prizes(competition_id);
CREATE INDEX IF NOT EXISTS idx_competition_templates_creator ON competition_templates(creator_id);
CREATE INDEX IF NOT EXISTS idx_competition_templates_public ON competition_templates(is_public) WHERE is_public = TRUE;
CREATE INDEX IF NOT EXISTS idx_execution_log_user_date ON execution_log(user_id, created_at);

-- ---------------------------------------------
-- 3.2 ARENAS (Coding Arenas)
-- ---------------------------------------------

CREATE TABLE IF NOT EXISTS arenas (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  title VARCHAR(255) NOT NULL,
  description TEXT,
  rules TEXT,
  creator_id VARCHAR(255) NOT NULL,
  status VARCHAR(50) DEFAULT 'waiting',
  max_participants INTEGER DEFAULT 10,
  time_limit_minutes INTEGER DEFAULT 60,
  allowed_languages TEXT[] DEFAULT ARRAY['python', 'javascript', 'java', 'cpp'],
  problem_title VARCHAR(255),
  problem_description TEXT,
  test_cases JSONB DEFAULT '[]'::jsonb,
  starts_at TIMESTAMP WITH TIME ZONE,
  ends_at TIMESTAMP WITH TIME ZONE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS arena_participants (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  arena_id UUID NOT NULL REFERENCES arenas(id) ON DELETE CASCADE,
  user_id VARCHAR(255) NOT NULL,
  username VARCHAR(255),
  role VARCHAR(50) DEFAULT 'participant',
  status VARCHAR(50) DEFAULT 'active',
  joined_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  UNIQUE(arena_id, user_id)
);

CREATE TABLE IF NOT EXISTS arena_submissions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  arena_id UUID NOT NULL REFERENCES arenas(id) ON DELETE CASCADE,
  user_id VARCHAR(255) NOT NULL,
  code TEXT NOT NULL,
  language VARCHAR(50) NOT NULL,
  status VARCHAR(50) DEFAULT 'pending',
  score INTEGER DEFAULT 0,
  execution_time INTEGER,
  tests_passed INTEGER DEFAULT 0,
  tests_total INTEGER DEFAULT 0,
  error_message TEXT,
  submitted_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS arena_scores (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  arena_id UUID NOT NULL REFERENCES arenas(id) ON DELETE CASCADE,
  user_id VARCHAR(255) NOT NULL,
  score INTEGER DEFAULT 0,
  best_time INTEGER,
  submissions_count INTEGER DEFAULT 0,
  last_submission_at TIMESTAMP WITH TIME ZONE,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  UNIQUE(arena_id, user_id)
);

-- Arena indexes
CREATE INDEX IF NOT EXISTS idx_arenas_creator ON arenas(creator_id);
CREATE INDEX IF NOT EXISTS idx_arenas_status ON arenas(status);
CREATE INDEX IF NOT EXISTS idx_arena_participants_arena ON arena_participants(arena_id);
CREATE INDEX IF NOT EXISTS idx_arena_participants_user ON arena_participants(user_id);
CREATE INDEX IF NOT EXISTS idx_arena_submissions_arena ON arena_submissions(arena_id);
CREATE INDEX IF NOT EXISTS idx_arena_submissions_user ON arena_submissions(user_id);
CREATE INDEX IF NOT EXISTS idx_arena_scores_arena ON arena_scores(arena_id);

-- ---------------------------------------------
-- 3.3 SKILL RATINGS & LEADERBOARDS
-- ---------------------------------------------

CREATE TABLE IF NOT EXISTS user_skill_ratings (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id VARCHAR(255) NOT NULL UNIQUE,
  skill_rating INTEGER DEFAULT 1000,
  skill_tier VARCHAR(50) DEFAULT 'Bronze',
  peak_rating INTEGER DEFAULT 1000,
  competitions_completed INTEGER DEFAULT 0,
  win_count INTEGER DEFAULT 0,
  top3_count INTEGER DEFAULT 0,
  average_percentile DECIMAL(5,2) DEFAULT 50.00,
  current_streak INTEGER DEFAULT 0,
  longest_streak INTEGER DEFAULT 0,
  last_competition_at TIMESTAMP WITH TIME ZONE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS skill_rating_history (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id VARCHAR(255) NOT NULL,
  competition_id UUID REFERENCES competitions(id) ON DELETE SET NULL,
  old_rating INTEGER NOT NULL,
  new_rating INTEGER NOT NULL,
  rating_change INTEGER NOT NULL,
  position INTEGER,
  total_participants INTEGER,
  percentile DECIMAL(5,2),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Also create alias for backwards compatibility
CREATE TABLE IF NOT EXISTS user_ratings (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id VARCHAR(255) NOT NULL UNIQUE,
  skill_rating INTEGER DEFAULT 1000,
  skill_tier VARCHAR(50) DEFAULT 'Bronze',
  total_competitions INTEGER DEFAULT 0,
  total_wins INTEGER DEFAULT 0,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Rating indexes
CREATE INDEX IF NOT EXISTS idx_user_skill_ratings_user ON user_skill_ratings(user_id);
CREATE INDEX IF NOT EXISTS idx_user_skill_ratings_rating ON user_skill_ratings(skill_rating DESC);
CREATE INDEX IF NOT EXISTS idx_skill_rating_history_user ON skill_rating_history(user_id);

-- ---------------------------------------------
-- 3.4 DUELS (1v1 System)
-- ---------------------------------------------

CREATE TABLE IF NOT EXISTS duel_challenges (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  title VARCHAR(255) NOT NULL,
  description TEXT NOT NULL,
  difficulty VARCHAR(20) NOT NULL,
  category VARCHAR(50),
  time_limit_seconds INTEGER DEFAULT 300,
  test_cases JSONB NOT NULL,
  starter_code JSONB,
  solution_code JSONB,
  times_used INTEGER DEFAULT 0,
  avg_solve_time INTEGER,
  pass_rate DECIMAL(5,2),
  is_active BOOLEAN DEFAULT TRUE,
  created_by VARCHAR(255),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS duel_queue (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id VARCHAR(255) NOT NULL UNIQUE,
  username VARCHAR(255) NOT NULL,
  skill_rating INTEGER DEFAULT 1000,
  selected_language VARCHAR(50) NOT NULL,
  difficulty_preference VARCHAR(20),
  queued_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  expires_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() + INTERVAL '2 minutes'
);

CREATE TABLE IF NOT EXISTS duels (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  challenge_id UUID NOT NULL REFERENCES duel_challenges(id),
  player1_id VARCHAR(255) NOT NULL,
  player1_username VARCHAR(255) NOT NULL,
  player1_rating INTEGER NOT NULL,
  player2_id VARCHAR(255),
  player2_username VARCHAR(255),
  player2_rating INTEGER,
  player2_is_bot BOOLEAN DEFAULT FALSE,
  language VARCHAR(50) NOT NULL,
  status VARCHAR(20) DEFAULT 'waiting',
  winner_id VARCHAR(255),
  player1_score INTEGER DEFAULT 0,
  player2_score INTEGER DEFAULT 0,
  player1_time INTEGER,
  player2_time INTEGER,
  player1_submitted_at TIMESTAMP WITH TIME ZONE,
  player2_submitted_at TIMESTAMP WITH TIME ZONE,
  rating_change_p1 INTEGER,
  rating_change_p2 INTEGER,
  challenge_type VARCHAR(20) DEFAULT 'random',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  started_at TIMESTAMP WITH TIME ZONE,
  ended_at TIMESTAMP WITH TIME ZONE
);

CREATE TABLE IF NOT EXISTS duel_submissions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  duel_id UUID NOT NULL REFERENCES duels(id) ON DELETE CASCADE,
  user_id VARCHAR(255) NOT NULL,
  code TEXT NOT NULL,
  language VARCHAR(50) NOT NULL,
  status VARCHAR(20) DEFAULT 'pending',
  score INTEGER DEFAULT 0,
  tests_passed INTEGER DEFAULT 0,
  tests_total INTEGER DEFAULT 0,
  execution_time INTEGER,
  error_message TEXT,
  submitted_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS duel_challenges_sent (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  challenger_id VARCHAR(255) NOT NULL,
  challenger_username VARCHAR(255) NOT NULL,
  challenged_id VARCHAR(255) NOT NULL,
  challenged_username VARCHAR(255) NOT NULL,
  language VARCHAR(50) NOT NULL,
  difficulty VARCHAR(20) DEFAULT 'medium',
  status VARCHAR(20) DEFAULT 'pending',
  duel_id UUID REFERENCES duels(id),
  message TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  expires_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() + INTERVAL '24 hours',
  responded_at TIMESTAMP WITH TIME ZONE
);

-- Duel indexes
CREATE INDEX IF NOT EXISTS idx_duel_queue_rating ON duel_queue(skill_rating);
CREATE INDEX IF NOT EXISTS idx_duel_queue_language ON duel_queue(selected_language);
CREATE INDEX IF NOT EXISTS idx_duel_queue_expires ON duel_queue(expires_at);
CREATE INDEX IF NOT EXISTS idx_duels_player1 ON duels(player1_id);
CREATE INDEX IF NOT EXISTS idx_duels_player2 ON duels(player2_id);
CREATE INDEX IF NOT EXISTS idx_duels_status ON duels(status);
CREATE INDEX IF NOT EXISTS idx_duel_submissions_duel ON duel_submissions(duel_id);
CREATE INDEX IF NOT EXISTS idx_duel_challenges_sent_challenged ON duel_challenges_sent(challenged_id, status);
CREATE INDEX IF NOT EXISTS idx_duel_challenges_difficulty ON duel_challenges(difficulty, is_active);

-- ---------------------------------------------
-- 3.5 DAILY CHALLENGES & STREAKS
-- ---------------------------------------------

CREATE TABLE IF NOT EXISTS daily_challenges (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  challenge_date DATE UNIQUE,
  title VARCHAR(255) NOT NULL,
  description TEXT NOT NULL,
  difficulty VARCHAR(20) DEFAULT 'medium' CHECK (difficulty IN ('easy', 'medium', 'hard', 'expert')),
  category VARCHAR(100),
  time_limit_minutes INTEGER DEFAULT 30,
  test_cases JSONB NOT NULL,
  starter_code JSONB DEFAULT '{}',
  allowed_languages TEXT[] DEFAULT ARRAY['python', 'javascript', 'java', 'cpp', 'go'],
  xp_reward INTEGER DEFAULT 100,
  streak_bonus_multiplier DECIMAL(3,2) DEFAULT 1.5,
  active_date DATE,
  source_challenge_id UUID REFERENCES duel_challenges(id),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS daily_challenge_test_cases (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  challenge_id UUID NOT NULL REFERENCES daily_challenges(id) ON DELETE CASCADE,
  input TEXT NOT NULL,
  expected_output TEXT NOT NULL,
  is_hidden BOOLEAN DEFAULT FALSE,
  points INTEGER DEFAULT 50,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS daily_submissions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  daily_challenge_id UUID NOT NULL REFERENCES daily_challenges(id) ON DELETE CASCADE,
  user_id VARCHAR(255) NOT NULL,
  code TEXT NOT NULL,
  language VARCHAR(50) NOT NULL,
  score INTEGER DEFAULT 0,
  passed BOOLEAN DEFAULT FALSE,
  execution_time INTEGER,
  submitted_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  UNIQUE(daily_challenge_id, user_id)
);

CREATE TABLE IF NOT EXISTS user_streaks (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id VARCHAR(255) NOT NULL UNIQUE,
  current_streak INTEGER DEFAULT 0,
  longest_streak INTEGER DEFAULT 0,
  last_completed_date DATE,
  total_daily_completed INTEGER DEFAULT 0,
  total_xp_earned INTEGER DEFAULT 0,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Daily challenge indexes
CREATE INDEX IF NOT EXISTS idx_daily_challenges_date ON daily_challenges(challenge_date);
CREATE INDEX IF NOT EXISTS idx_daily_submissions_user ON daily_submissions(user_id);
CREATE INDEX IF NOT EXISTS idx_daily_submissions_challenge ON daily_submissions(daily_challenge_id);
CREATE INDEX IF NOT EXISTS idx_user_streaks_user ON user_streaks(user_id);

-- ---------------------------------------------
-- 3.6 ACHIEVEMENTS
-- ---------------------------------------------

CREATE TABLE IF NOT EXISTS achievements (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  slug VARCHAR(100) NOT NULL UNIQUE,
  name VARCHAR(255) NOT NULL,
  description TEXT NOT NULL,
  category VARCHAR(50) NOT NULL CHECK (category IN ('competition', 'duel', 'streak', 'skill', 'social', 'special', 'submissions', 'scores', 'competitions', 'streaks', 'duels', 'tutorials', 'languages', 'speed', 'rating')),
  icon VARCHAR(50) NOT NULL,
  rarity VARCHAR(20) DEFAULT 'common' CHECK (rarity IN ('common', 'uncommon', 'rare', 'epic', 'legendary')),
  xp_reward INTEGER DEFAULT 50,
  requirement_type VARCHAR(50) NOT NULL,
  requirement_value INTEGER,
  requirement_data JSONB DEFAULT '{}',
  is_secret BOOLEAN DEFAULT FALSE,
  is_active BOOLEAN DEFAULT TRUE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS user_achievements (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id VARCHAR(255) NOT NULL,
  achievement_id UUID NOT NULL REFERENCES achievements(id) ON DELETE CASCADE,
  progress INTEGER DEFAULT 0,
  unlocked BOOLEAN DEFAULT FALSE,
  unlocked_at TIMESTAMP WITH TIME ZONE,
  notified BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  UNIQUE(user_id, achievement_id)
);

-- Achievement indexes
CREATE INDEX IF NOT EXISTS idx_user_achievements_user ON user_achievements(user_id);
CREATE INDEX IF NOT EXISTS idx_user_achievements_unlocked ON user_achievements(unlocked);

-- ---------------------------------------------
-- 3.7 SPECTATING
-- ---------------------------------------------

CREATE TABLE IF NOT EXISTS spectate_sessions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  duel_id UUID REFERENCES duels(id) ON DELETE CASCADE,
  competition_id UUID REFERENCES competitions(id) ON DELETE CASCADE,
  arena_id UUID,
  session_type VARCHAR(20) NOT NULL CHECK (session_type IN ('duel', 'competition', 'arena')),
  is_live BOOLEAN DEFAULT TRUE,
  viewer_count INTEGER DEFAULT 0,
  started_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  ended_at TIMESTAMP WITH TIME ZONE,
  CONSTRAINT one_source CHECK (
    (duel_id IS NOT NULL AND competition_id IS NULL AND arena_id IS NULL) OR
    (duel_id IS NULL AND competition_id IS NOT NULL AND arena_id IS NULL) OR
    (duel_id IS NULL AND competition_id IS NULL AND arena_id IS NOT NULL)
  )
);

CREATE TABLE IF NOT EXISTS spectators (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  session_id UUID NOT NULL REFERENCES spectate_sessions(id) ON DELETE CASCADE,
  user_id VARCHAR(255) NOT NULL,
  username VARCHAR(255),
  joined_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  left_at TIMESTAMP WITH TIME ZONE,
  UNIQUE(session_id, user_id)
);

CREATE TABLE IF NOT EXISTS spectate_emotes (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  session_id UUID NOT NULL REFERENCES spectate_sessions(id) ON DELETE CASCADE,
  user_id VARCHAR(255) NOT NULL,
  emote VARCHAR(50) NOT NULL,
  timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS spectate_chat (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  session_id UUID NOT NULL REFERENCES spectate_sessions(id) ON DELETE CASCADE,
  user_id VARCHAR(255) NOT NULL,
  username VARCHAR(255),
  message TEXT NOT NULL,
  is_highlight BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Spectate indexes
CREATE INDEX IF NOT EXISTS idx_spectate_sessions_duel ON spectate_sessions(duel_id);
CREATE INDEX IF NOT EXISTS idx_spectate_sessions_live ON spectate_sessions(is_live);
CREATE INDEX IF NOT EXISTS idx_spectators_session ON spectators(session_id);
CREATE INDEX IF NOT EXISTS idx_spectate_emotes_session ON spectate_emotes(session_id);
CREATE INDEX IF NOT EXISTS idx_spectate_chat_session ON spectate_chat(session_id);

-- ---------------------------------------------
-- 3.8 FRIENDS & SOCIAL
-- ---------------------------------------------

CREATE TABLE IF NOT EXISTS friendships (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id VARCHAR(255) NOT NULL,
  friend_id VARCHAR(255) NOT NULL,
  status VARCHAR(20) DEFAULT 'pending' CHECK (status IN ('pending', 'accepted', 'blocked')),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  accepted_at TIMESTAMP WITH TIME ZONE,
  UNIQUE(user_id, friend_id)
);

CREATE TABLE IF NOT EXISTS user_presence (
  user_id VARCHAR(255) PRIMARY KEY,
  is_online BOOLEAN DEFAULT FALSE,
  last_seen TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  current_activity VARCHAR(100),
  activity_details JSONB DEFAULT '{}'
);

-- Social indexes
CREATE INDEX IF NOT EXISTS idx_friendships_user ON friendships(user_id);
CREATE INDEX IF NOT EXISTS idx_friendships_friend ON friendships(friend_id);
CREATE INDEX IF NOT EXISTS idx_friendships_status ON friendships(status);

-- ---------------------------------------------
-- 3.9 NOTIFICATIONS
-- ---------------------------------------------

CREATE TABLE IF NOT EXISTS notifications (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id VARCHAR(255) NOT NULL,
  type VARCHAR(50) NOT NULL,
  title VARCHAR(255) NOT NULL,
  message TEXT,
  data JSONB DEFAULT '{}',
  is_read BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS notification_preferences (
  user_id VARCHAR(255) PRIMARY KEY,
  email_friend_requests BOOLEAN DEFAULT TRUE,
  email_duel_invites BOOLEAN DEFAULT TRUE,
  email_competition_reminders BOOLEAN DEFAULT TRUE,
  email_achievements BOOLEAN DEFAULT FALSE,
  push_enabled BOOLEAN DEFAULT TRUE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Notification indexes
CREATE INDEX IF NOT EXISTS idx_notifications_user ON notifications(user_id);
CREATE INDEX IF NOT EXISTS idx_notifications_read ON notifications(user_id, is_read);
CREATE INDEX IF NOT EXISTS idx_notifications_created ON notifications(created_at DESC);

-- ---------------------------------------------
-- 3.10 TUTORIALS
-- ---------------------------------------------

CREATE TABLE IF NOT EXISTS tutorial_lessons (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  slug VARCHAR(100) UNIQUE NOT NULL,
  title VARCHAR(255) NOT NULL,
  description TEXT,
  category VARCHAR(50) NOT NULL,
  difficulty VARCHAR(20) DEFAULT 'beginner' CHECK (difficulty IN ('beginner', 'intermediate', 'advanced')),
  order_index INTEGER DEFAULT 0,
  content TEXT NOT NULL,
  hints JSONB DEFAULT '[]',
  starter_code JSONB DEFAULT '{}',
  solution_code JSONB DEFAULT '{}',
  test_cases JSONB NOT NULL,
  xp_reward INTEGER DEFAULT 25,
  estimated_minutes INTEGER DEFAULT 10,
  prerequisites UUID[] DEFAULT '{}',
  is_active BOOLEAN DEFAULT TRUE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS tutorial_progress (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id VARCHAR(255) NOT NULL,
  lesson_id UUID NOT NULL REFERENCES tutorial_lessons(id) ON DELETE CASCADE,
  status VARCHAR(20) DEFAULT 'not_started' CHECK (status IN ('not_started', 'in_progress', 'completed')),
  hints_used INTEGER DEFAULT 0,
  attempts INTEGER DEFAULT 0,
  best_code TEXT,
  best_language VARCHAR(50),
  completed_at TIMESTAMP WITH TIME ZONE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  UNIQUE(user_id, lesson_id)
);

-- Tutorial indexes
CREATE INDEX IF NOT EXISTS idx_tutorial_lessons_category ON tutorial_lessons(category);
CREATE INDEX IF NOT EXISTS idx_tutorial_lessons_difficulty ON tutorial_lessons(difficulty);
CREATE INDEX IF NOT EXISTS idx_tutorial_lessons_order ON tutorial_lessons(category, order_index);
CREATE INDEX IF NOT EXISTS idx_tutorial_progress_user ON tutorial_progress(user_id);

-- ---------------------------------------------
-- 3.11 USER PROFILES & SETTINGS
-- ---------------------------------------------

CREATE TABLE IF NOT EXISTS user_profiles (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id VARCHAR(255) NOT NULL UNIQUE,
  bio TEXT,
  location VARCHAR(255),
  website VARCHAR(500),
  github_username VARCHAR(100),
  twitter_username VARCHAR(100),
  linkedin_url VARCHAR(500),
  preferred_language VARCHAR(50) DEFAULT 'python',
  theme VARCHAR(20) DEFAULT 'system',
  email_public BOOLEAN DEFAULT FALSE,
  show_activity BOOLEAN DEFAULT TRUE,
  stripe_customer_id VARCHAR(255),
  stripe_subscription_id VARCHAR(255),
  subscription_tier VARCHAR(20) DEFAULT 'free',
  subscription_status VARCHAR(50),
  subscription_current_period_end TIMESTAMP WITH TIME ZONE,
  subscription_cancel_at_period_end BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_user_profiles_user_id ON user_profiles(user_id);
CREATE INDEX IF NOT EXISTS idx_user_profiles_stripe_customer ON user_profiles(stripe_customer_id);
CREATE INDEX IF NOT EXISTS idx_user_profiles_subscription_tier ON user_profiles(subscription_tier);

-- ---------------------------------------------
-- 3.12 GITHUB INTEGRATION
-- ---------------------------------------------

CREATE TABLE IF NOT EXISTS user_github_tokens (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id VARCHAR(255) NOT NULL UNIQUE,
  access_token TEXT NOT NULL,
  refresh_token TEXT,
  token_type VARCHAR(50) DEFAULT 'bearer',
  scope TEXT,
  expires_at TIMESTAMP WITH TIME ZONE,
  github_user_id VARCHAR(100),
  github_username VARCHAR(100),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_user_github_tokens_user ON user_github_tokens(user_id);

-- ---------------------------------------------
-- 3.13 CODE PLAYGROUND & TEMPLATES
-- ---------------------------------------------

CREATE TABLE IF NOT EXISTS playground_sessions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id VARCHAR(255),
  title VARCHAR(255) DEFAULT 'Untitled',
  code TEXT NOT NULL,
  language VARCHAR(50) NOT NULL DEFAULT 'python',
  input TEXT DEFAULT '',
  last_output TEXT,
  is_public BOOLEAN DEFAULT FALSE,
  share_slug VARCHAR(20) UNIQUE,
  fork_count INTEGER DEFAULT 0,
  forked_from UUID REFERENCES playground_sessions(id),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS code_templates (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id VARCHAR(255),
  name VARCHAR(255) NOT NULL,
  description TEXT,
  code TEXT NOT NULL,
  language VARCHAR(50) NOT NULL,
  is_public BOOLEAN DEFAULT FALSE,
  category VARCHAR(100),
  tags TEXT[] DEFAULT '{}',
  use_count INTEGER DEFAULT 0,
  is_starter BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Playground indexes
CREATE INDEX IF NOT EXISTS idx_playground_user ON playground_sessions(user_id);
CREATE INDEX IF NOT EXISTS idx_playground_public ON playground_sessions(is_public);
CREATE INDEX IF NOT EXISTS idx_playground_share_slug ON playground_sessions(share_slug);

-- ---------------------------------------------
-- 3.14 PRACTICE MODE
-- ---------------------------------------------

CREATE TABLE IF NOT EXISTS practice_sessions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id VARCHAR(255) NOT NULL,
  challenge_type VARCHAR(50) NOT NULL,
  challenge_id UUID NOT NULL,
  original_duel_id UUID,
  code TEXT,
  language VARCHAR(50) NOT NULL,
  score INTEGER DEFAULT 0,
  tests_passed INTEGER DEFAULT 0,
  tests_total INTEGER DEFAULT 0,
  attempts INTEGER DEFAULT 1,
  best_score INTEGER DEFAULT 0,
  completed BOOLEAN DEFAULT FALSE,
  started_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  completed_at TIMESTAMP WITH TIME ZONE
);

CREATE INDEX IF NOT EXISTS idx_practice_user ON practice_sessions(user_id);
CREATE INDEX IF NOT EXISTS idx_practice_challenge ON practice_sessions(challenge_type, challenge_id);

-- ---------------------------------------------
-- 3.15 INVITES SYSTEM
-- ---------------------------------------------

CREATE TABLE IF NOT EXISTS competition_invites (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  competition_id UUID REFERENCES competitions(id) ON DELETE CASCADE,
  invite_code VARCHAR(20) NOT NULL UNIQUE,
  created_by VARCHAR(255) NOT NULL,
  max_uses INTEGER DEFAULT NULL,
  uses_count INTEGER DEFAULT 0,
  expires_at TIMESTAMP WITH TIME ZONE,
  is_active BOOLEAN DEFAULT TRUE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS arena_invites (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  arena_id UUID REFERENCES arenas(id) ON DELETE CASCADE,
  invite_code VARCHAR(20) NOT NULL UNIQUE,
  created_by VARCHAR(255) NOT NULL,
  max_uses INTEGER DEFAULT NULL,
  uses_count INTEGER DEFAULT 0,
  expires_at TIMESTAMP WITH TIME ZONE,
  is_active BOOLEAN DEFAULT TRUE,
  role VARCHAR(50) DEFAULT 'participant',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS invite_redemptions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  invite_type VARCHAR(20) NOT NULL,
  invite_id UUID NOT NULL,
  user_id VARCHAR(255) NOT NULL,
  redeemed_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  UNIQUE(invite_type, invite_id, user_id)
);

-- Invite indexes
CREATE INDEX IF NOT EXISTS idx_comp_invites_code ON competition_invites(invite_code);
CREATE INDEX IF NOT EXISTS idx_arena_invites_code ON arena_invites(invite_code);
CREATE INDEX IF NOT EXISTS idx_invite_redemptions_user ON invite_redemptions(user_id);

-- ---------------------------------------------
-- 3.16 USAGE TRACKING (Stripe Metered Billing)
-- ---------------------------------------------

CREATE TABLE IF NOT EXISTS usage_tracking (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id VARCHAR(255) NOT NULL,
  date DATE NOT NULL DEFAULT CURRENT_DATE,
  execution_count INTEGER DEFAULT 0,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  UNIQUE(user_id, date)
);

CREATE TABLE IF NOT EXISTS payment_history (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id VARCHAR(255) NOT NULL,
  stripe_payment_intent_id VARCHAR(255),
  stripe_invoice_id VARCHAR(255),
  amount_cents INTEGER NOT NULL,
  currency VARCHAR(3) DEFAULT 'usd',
  status VARCHAR(50) NOT NULL,
  description TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Usage indexes
CREATE INDEX IF NOT EXISTS idx_usage_tracking_user_date ON usage_tracking(user_id, date);
CREATE INDEX IF NOT EXISTS idx_payment_history_user ON payment_history(user_id);

-- ---------------------------------------------
-- 3.17 TERMINAL SESSIONS
-- ---------------------------------------------

CREATE TABLE IF NOT EXISTS terminal_sessions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id VARCHAR(255) NOT NULL,
  arena_id UUID REFERENCES arenas(id) ON DELETE CASCADE,
  status VARCHAR(50) DEFAULT 'active',
  last_activity TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_terminal_sessions_user ON terminal_sessions(user_id);
CREATE INDEX IF NOT EXISTS idx_terminal_sessions_arena ON terminal_sessions(arena_id);

-- ---------------------------------------------
-- 3.18 CHALLENGE REPORTS
-- ---------------------------------------------

CREATE TABLE IF NOT EXISTS challenge_reports (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  challenge_id UUID,
  challenge_type VARCHAR(50) NOT NULL,
  user_id VARCHAR(255) NOT NULL,
  reason VARCHAR(100) NOT NULL,
  description TEXT,
  status VARCHAR(20) DEFAULT 'pending',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_challenge_reports_status ON challenge_reports(status);

-- ---------------------------------------------
-- 3.19 CHALLENGE METADATA
-- ---------------------------------------------

CREATE TABLE IF NOT EXISTS challenge_metadata (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  challenge_id UUID NOT NULL,
  challenge_type VARCHAR(50) NOT NULL,
  tags TEXT[] DEFAULT '{}',
  difficulty_votes JSONB DEFAULT '{}',
  avg_solve_time INTEGER,
  solve_count INTEGER DEFAULT 0,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- ---------------------------------------------
-- 3.20 DUEL REALTIME STATE
-- ---------------------------------------------

CREATE TABLE IF NOT EXISTS duel_realtime_state (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  duel_id UUID NOT NULL REFERENCES duels(id) ON DELETE CASCADE UNIQUE,
  player1_typing BOOLEAN DEFAULT FALSE,
  player1_last_run TIMESTAMP WITH TIME ZONE,
  player1_tests_passing INTEGER DEFAULT 0,
  player2_typing BOOLEAN DEFAULT FALSE,
  player2_last_run TIMESTAMP WITH TIME ZONE,
  player2_tests_passing INTEGER DEFAULT 0,
  current_phase VARCHAR(50) DEFAULT 'coding',
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_duel_realtime_duel ON duel_realtime_state(duel_id);

-- ---------------------------------------------
-- 3.21 SUBMISSION COMPARISONS
-- ---------------------------------------------

CREATE TABLE IF NOT EXISTS submission_comparisons (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id VARCHAR(255) NOT NULL,
  submission_a_id UUID NOT NULL REFERENCES submissions(id) ON DELETE CASCADE,
  submission_b_id UUID NOT NULL REFERENCES submissions(id) ON DELETE CASCADE,
  notes TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_comparisons_user ON submission_comparisons(user_id);

-- =============================================
-- SECTION 4: VIEWS
-- =============================================

-- Leaderboard view for competitions
CREATE OR REPLACE VIEW leaderboard AS
SELECT 
  s.competition_id,
  s.user_id,
  MAX(s.score) as best_score,
  MIN(s.execution_time) as best_time,
  COUNT(s.id) as total_submissions,
  MAX(s.submitted_at) as last_submission,
  RANK() OVER (PARTITION BY s.competition_id ORDER BY MAX(s.score) DESC, MIN(s.execution_time) ASC) as rank
FROM submissions s
WHERE s.status = 'passed'
GROUP BY s.competition_id, s.user_id;

-- Arena leaderboard view
CREATE OR REPLACE VIEW arena_leaderboard AS
SELECT 
  as2.arena_id,
  as2.user_id,
  ap.username,
  as2.score as best_score,
  as2.best_time,
  as2.submissions_count,
  as2.last_submission_at,
  RANK() OVER (PARTITION BY as2.arena_id ORDER BY as2.score DESC, as2.best_time ASC) as rank
FROM arena_scores as2
JOIN arena_participants ap ON ap.arena_id = as2.arena_id AND ap.user_id = as2.user_id
WHERE as2.score > 0;

-- Global skill leaderboard view
CREATE OR REPLACE VIEW skill_leaderboard AS
SELECT 
  usr.user_id,
  usr.skill_rating,
  usr.skill_tier,
  usr.peak_rating,
  usr.competitions_completed,
  usr.win_count,
  usr.top3_count,
  usr.average_percentile,
  usr.current_streak,
  usr.last_competition_at,
  RANK() OVER (ORDER BY usr.skill_rating DESC) as global_rank
FROM user_skill_ratings usr
WHERE usr.competitions_completed >= 3
ORDER BY usr.skill_rating DESC;

-- =============================================
-- SECTION 5: FUNCTIONS
-- =============================================

-- Helper function to get current user ID
CREATE OR REPLACE FUNCTION current_user_id()
RETURNS VARCHAR(255) AS $$
BEGIN
  RETURN current_setting('app.user_id', true);
END;
$$ LANGUAGE plpgsql STABLE;

-- Auto-cleanup old execution logs
CREATE OR REPLACE FUNCTION cleanup_old_execution_logs()
RETURNS void AS $$
BEGIN
  DELETE FROM execution_log WHERE created_at < NOW() - INTERVAL '2 days';
END;
$$ LANGUAGE plpgsql;

-- Cleanup orphan test results
CREATE OR REPLACE FUNCTION cleanup_orphan_test_results()
RETURNS INTEGER AS $$
DECLARE
  deleted_count INTEGER;
BEGIN
  DELETE FROM test_results tr
  WHERE NOT EXISTS (
    SELECT 1 FROM submissions s WHERE s.id = tr.submission_id
  );
  GET DIAGNOSTICS deleted_count = ROW_COUNT;
  RETURN deleted_count;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Cleanup orphan arena scores
CREATE OR REPLACE FUNCTION cleanup_orphan_arena_scores()
RETURNS INTEGER AS $$
DECLARE
  deleted_count INTEGER;
BEGIN
  DELETE FROM arena_scores asc2
  WHERE NOT EXISTS (
    SELECT 1 FROM arenas a WHERE a.id = asc2.arena_id
  );
  GET DIAGNOSTICS deleted_count = ROW_COUNT;
  RETURN deleted_count;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Cleanup old terminal sessions
CREATE OR REPLACE FUNCTION cleanup_old_terminal_sessions(days_old INTEGER DEFAULT 7)
RETURNS INTEGER AS $$
DECLARE
  deleted_count INTEGER;
BEGIN
  DELETE FROM terminal_sessions
  WHERE created_at < NOW() - (days_old || ' days')::INTERVAL;
  GET DIAGNOSTICS deleted_count = ROW_COUNT;
  RETURN deleted_count;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Cleanup old notifications
CREATE OR REPLACE FUNCTION cleanup_old_notifications(days_old INTEGER DEFAULT 30)
RETURNS INTEGER AS $$
DECLARE
  deleted_count INTEGER;
BEGIN
  DELETE FROM notifications
  WHERE is_read = TRUE
    AND created_at < NOW() - (days_old || ' days')::INTERVAL;
  GET DIAGNOSTICS deleted_count = ROW_COUNT;
  RETURN deleted_count;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Cleanup stale drafts
CREATE OR REPLACE FUNCTION cleanup_stale_drafts(days_old INTEGER DEFAULT 30)
RETURNS INTEGER AS $$
DECLARE
  deleted_count INTEGER;
BEGIN
  DELETE FROM competitions
  WHERE status = 'draft'
    AND created_at < NOW() - (days_old || ' days')::INTERVAL;
  GET DIAGNOSTICS deleted_count = ROW_COUNT;
  RETURN deleted_count;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Cleanup old failed submissions
CREATE OR REPLACE FUNCTION cleanup_old_failed_submissions(days_old INTEGER DEFAULT 90)
RETURNS INTEGER AS $$
DECLARE
  deleted_count INTEGER;
BEGIN
  DELETE FROM submissions
  WHERE status = 'failed'
    AND submitted_at < NOW() - (days_old || ' days')::INTERVAL;
  GET DIAGNOSTICS deleted_count = ROW_COUNT;
  RETURN deleted_count;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Cleanup expired GitHub tokens
CREATE OR REPLACE FUNCTION cleanup_expired_github_tokens()
RETURNS INTEGER AS $$
DECLARE
  deleted_count INTEGER;
BEGIN
  DELETE FROM user_github_tokens
  WHERE expires_at IS NOT NULL
    AND expires_at < NOW() - INTERVAL '1 day';
  GET DIAGNOSTICS deleted_count = ROW_COUNT;
  RETURN deleted_count;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Cleanup old skill rating history
CREATE OR REPLACE FUNCTION cleanup_old_skill_history()
RETURNS INTEGER AS $$
DECLARE
  deleted_count INTEGER;
BEGIN
  WITH ranked_history AS (
    SELECT id, ROW_NUMBER() OVER (
      PARTITION BY user_id 
      ORDER BY created_at DESC
    ) as rn
    FROM skill_rating_history
  )
  DELETE FROM skill_rating_history
  WHERE id IN (
    SELECT id FROM ranked_history WHERE rn > 100
  );
  GET DIAGNOSTICS deleted_count = ROW_COUNT;
  RETURN deleted_count;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Cleanup old challenge reports
CREATE OR REPLACE FUNCTION cleanup_old_challenge_reports(days_old INTEGER DEFAULT 90)
RETURNS INTEGER AS $$
DECLARE
  deleted_count INTEGER;
BEGIN
  DELETE FROM challenge_reports
  WHERE status IN ('resolved', 'dismissed')
    AND created_at < NOW() - (days_old || ' days')::INTERVAL;
  GET DIAGNOSTICS deleted_count = ROW_COUNT;
  RETURN deleted_count;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Master cleanup function
CREATE OR REPLACE FUNCTION run_all_cleanups()
RETURNS TABLE (
  cleanup_name TEXT,
  items_cleaned INTEGER
) AS $$
BEGIN
  cleanup_name := 'orphan_test_results';
  items_cleaned := cleanup_orphan_test_results();
  RETURN NEXT;

  cleanup_name := 'orphan_arena_scores';
  items_cleaned := cleanup_orphan_arena_scores();
  RETURN NEXT;

  cleanup_name := 'old_terminal_sessions';
  items_cleaned := cleanup_old_terminal_sessions(7);
  RETURN NEXT;

  cleanup_name := 'old_notifications';
  items_cleaned := cleanup_old_notifications(30);
  RETURN NEXT;

  cleanup_name := 'stale_drafts';
  items_cleaned := cleanup_stale_drafts(30);
  RETURN NEXT;

  cleanup_name := 'old_failed_submissions';
  items_cleaned := cleanup_old_failed_submissions(90);
  RETURN NEXT;

  cleanup_name := 'expired_github_tokens';
  items_cleaned := cleanup_expired_github_tokens();
  RETURN NEXT;

  cleanup_name := 'old_skill_history';
  items_cleaned := cleanup_old_skill_history();
  RETURN NEXT;

  cleanup_name := 'old_challenge_reports';
  items_cleaned := cleanup_old_challenge_reports(90);
  RETURN NEXT;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Increment execution count
CREATE OR REPLACE FUNCTION increment_execution_count(p_user_id VARCHAR(255))
RETURNS TABLE(count INTEGER, date DATE) AS $$
DECLARE
  v_count INTEGER;
  v_date DATE;
BEGIN
  v_date := CURRENT_DATE;
  
  INSERT INTO usage_tracking (user_id, date, execution_count)
  VALUES (p_user_id, v_date, 1)
  ON CONFLICT (user_id, date) 
  DO UPDATE SET 
    execution_count = usage_tracking.execution_count + 1,
    updated_at = NOW()
  RETURNING usage_tracking.execution_count, usage_tracking.date INTO v_count, v_date;
  
  RETURN QUERY SELECT v_count, v_date;
END;
$$ LANGUAGE plpgsql;

-- Get daily usage
CREATE OR REPLACE FUNCTION get_daily_usage(p_user_id VARCHAR(255))
RETURNS INTEGER AS $$
DECLARE
  v_count INTEGER;
BEGIN
  SELECT execution_count INTO v_count
  FROM usage_tracking
  WHERE user_id = p_user_id AND date = CURRENT_DATE;
  
  RETURN COALESCE(v_count, 0);
END;
$$ LANGUAGE plpgsql;

-- Calculate skill rating change
CREATE OR REPLACE FUNCTION calculate_skill_rating_change(
  p_current_rating INTEGER,
  p_position INTEGER,
  p_total_participants INTEGER,
  p_competition_difficulty VARCHAR(20) DEFAULT 'medium'
)
RETURNS TABLE (
  new_rating INTEGER,
  rating_change INTEGER,
  new_tier VARCHAR(50),
  percentile DECIMAL(5,2)
) AS $$
DECLARE
  v_k_factor INTEGER;
  v_expected_position DECIMAL;
  v_actual_performance DECIMAL;
  v_rating_change INTEGER;
  v_new_rating INTEGER;
  v_percentile DECIMAL(5,2);
  v_tier VARCHAR(50);
BEGIN
  -- Set K-factor based on difficulty
  v_k_factor := CASE p_competition_difficulty
    WHEN 'easy' THEN 16
    WHEN 'medium' THEN 24
    WHEN 'hard' THEN 32
    WHEN 'expert' THEN 40
    ELSE 24
  END;
  
  -- Calculate percentile
  v_percentile := ((p_total_participants - p_position + 1)::DECIMAL / p_total_participants) * 100;
  
  -- Expected position based on rating
  v_expected_position := p_total_participants * 0.5;
  
  -- Performance score
  v_actual_performance := (p_total_participants - p_position + 1)::DECIMAL / p_total_participants;
  
  -- Rating change
  v_rating_change := ROUND(v_k_factor * (v_actual_performance - 0.5) * 2);
  
  -- Add bonus for top 3
  IF p_position <= 3 THEN
    v_rating_change := v_rating_change + (4 - p_position) * 5;
  END IF;
  
  v_new_rating := GREATEST(100, p_current_rating + v_rating_change);
  
  -- Determine tier
  v_tier := CASE
    WHEN v_new_rating >= 2400 THEN 'Grandmaster'
    WHEN v_new_rating >= 2100 THEN 'Master'
    WHEN v_new_rating >= 1800 THEN 'Diamond'
    WHEN v_new_rating >= 1500 THEN 'Platinum'
    WHEN v_new_rating >= 1200 THEN 'Gold'
    WHEN v_new_rating >= 900 THEN 'Silver'
    ELSE 'Bronze'
  END;
  
  RETURN QUERY SELECT v_new_rating, v_rating_change, v_tier, v_percentile;
END;
$$ LANGUAGE plpgsql;

-- Update user streak
CREATE OR REPLACE FUNCTION update_user_streak(
  p_user_id VARCHAR(255),
  p_xp_earned INTEGER DEFAULT 100
)
RETURNS TABLE (
  new_streak INTEGER,
  streak_bonus DECIMAL,
  total_xp INTEGER
) AS $$
DECLARE
  v_streak user_streaks%ROWTYPE;
  v_new_streak INTEGER;
  v_bonus DECIMAL := 1.0;
  v_total_xp INTEGER;
BEGIN
  SELECT * INTO v_streak FROM user_streaks WHERE user_id = p_user_id;
  
  IF NOT FOUND THEN
    INSERT INTO user_streaks (user_id, current_streak, longest_streak, last_completed_date, total_daily_completed, total_xp_earned)
    VALUES (p_user_id, 1, 1, CURRENT_DATE, 1, p_xp_earned)
    RETURNING current_streak, 1.0, total_xp_earned INTO v_new_streak, v_bonus, v_total_xp;
  ELSE
    IF v_streak.last_completed_date = CURRENT_DATE - INTERVAL '1 day' THEN
      v_new_streak := v_streak.current_streak + 1;
      v_bonus := LEAST(1.0 + (v_new_streak * 0.1), 2.0);
    ELSIF v_streak.last_completed_date = CURRENT_DATE THEN
      RETURN QUERY SELECT v_streak.current_streak, 1.0::DECIMAL, v_streak.total_xp_earned;
      RETURN;
    ELSE
      v_new_streak := 1;
      v_bonus := 1.0;
    END IF;
    
    v_total_xp := v_streak.total_xp_earned + ROUND(p_xp_earned * v_bonus);
    
    UPDATE user_streaks SET
      current_streak = v_new_streak,
      longest_streak = GREATEST(longest_streak, v_new_streak),
      last_completed_date = CURRENT_DATE,
      total_daily_completed = total_daily_completed + 1,
      total_xp_earned = v_total_xp,
      updated_at = NOW()
    WHERE user_id = p_user_id;
  END IF;
  
  RETURN QUERY SELECT v_new_streak, v_bonus, v_total_xp;
END;
$$ LANGUAGE plpgsql;

-- Check and unlock achievements
CREATE OR REPLACE FUNCTION check_achievements(
  p_user_id VARCHAR(255),
  p_category VARCHAR(50),
  p_metric_type VARCHAR(50),
  p_metric_value INTEGER
)
RETURNS TABLE (
  unlocked_achievement_id UUID,
  achievement_name VARCHAR(255),
  xp_earned INTEGER
) AS $$
BEGIN
  RETURN QUERY
  WITH eligible AS (
    SELECT a.id, a.name, a.xp_reward
    FROM achievements a
    LEFT JOIN user_achievements ua ON ua.achievement_id = a.id AND ua.user_id = p_user_id
    WHERE a.is_active = TRUE
      AND a.category = p_category
      AND a.requirement_type = p_metric_type
      AND a.requirement_value <= p_metric_value
      AND (ua.unlocked IS NULL OR ua.unlocked = FALSE)
  ),
  newly_unlocked AS (
    INSERT INTO user_achievements (user_id, achievement_id, progress, unlocked, unlocked_at)
    SELECT p_user_id, e.id, p_metric_value, TRUE, NOW()
    FROM eligible e
    ON CONFLICT (user_id, achievement_id) 
    DO UPDATE SET unlocked = TRUE, unlocked_at = NOW(), progress = p_metric_value
    WHERE user_achievements.unlocked = FALSE
    RETURNING achievement_id
  )
  SELECT e.id, e.name, e.xp_reward
  FROM eligible e
  JOIN newly_unlocked nu ON nu.achievement_id = e.id;
END;
$$ LANGUAGE plpgsql;

-- Find duel match
CREATE OR REPLACE FUNCTION find_duel_match(
  p_user_id VARCHAR(255),
  p_language VARCHAR(50),
  p_rating INTEGER,
  p_rating_range INTEGER DEFAULT 200
)
RETURNS TABLE (
  matched_user_id VARCHAR(255),
  matched_username VARCHAR(255),
  matched_rating INTEGER
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    dq.user_id,
    dq.username,
    dq.skill_rating
  FROM duel_queue dq
  WHERE dq.user_id != p_user_id
    AND dq.selected_language = p_language
    AND dq.skill_rating BETWEEN (p_rating - p_rating_range) AND (p_rating + p_rating_range)
    AND dq.expires_at > NOW()
  ORDER BY ABS(dq.skill_rating - p_rating) ASC
  LIMIT 1;
END;
$$ LANGUAGE plpgsql;

-- Calculate ELO change for duel
CREATE OR REPLACE FUNCTION calculate_duel_elo(
  p_winner_rating INTEGER,
  p_loser_rating INTEGER,
  p_is_draw BOOLEAN DEFAULT FALSE
)
RETURNS TABLE (
  winner_change INTEGER,
  loser_change INTEGER
) AS $$
DECLARE
  v_k_factor INTEGER := 32;
  v_expected_winner DECIMAL;
  v_expected_loser DECIMAL;
  v_winner_change INTEGER;
  v_loser_change INTEGER;
BEGIN
  v_expected_winner := 1.0 / (1.0 + POWER(10, (p_loser_rating - p_winner_rating)::DECIMAL / 400));
  v_expected_loser := 1.0 - v_expected_winner;
  
  IF p_is_draw THEN
    v_winner_change := ROUND(v_k_factor * (0.5 - v_expected_winner));
    v_loser_change := ROUND(v_k_factor * (0.5 - v_expected_loser));
  ELSE
    v_winner_change := ROUND(v_k_factor * (1.0 - v_expected_winner));
    v_loser_change := ROUND(v_k_factor * (0.0 - v_expected_loser));
  END IF;
  
  RETURN QUERY SELECT v_winner_change, v_loser_change;
END;
$$ LANGUAGE plpgsql;

-- Get random duel challenge
CREATE OR REPLACE FUNCTION get_random_duel_challenge(
  p_difficulty VARCHAR(20) DEFAULT NULL
)
RETURNS UUID AS $$
DECLARE
  v_challenge_id UUID;
BEGIN
  SELECT id INTO v_challenge_id
  FROM duel_challenges
  WHERE is_active = TRUE
    AND (p_difficulty IS NULL OR difficulty = p_difficulty)
  ORDER BY RANDOM()
  LIMIT 1;
  
  IF v_challenge_id IS NOT NULL THEN
    UPDATE duel_challenges 
    SET times_used = times_used + 1 
    WHERE id = v_challenge_id;
  END IF;
  
  RETURN v_challenge_id;
END;
$$ LANGUAGE plpgsql;

-- Cleanup duel queue
CREATE OR REPLACE FUNCTION cleanup_duel_queue()
RETURNS INTEGER AS $$
DECLARE
  deleted_count INTEGER;
BEGIN
  DELETE FROM duel_queue WHERE expires_at < NOW();
  GET DIAGNOSTICS deleted_count = ROW_COUNT;
  
  UPDATE duels 
  SET status = 'cancelled'
  WHERE status = 'waiting' 
    AND created_at < NOW() - INTERVAL '5 minutes';
    
  UPDATE duels
  SET status = 'cancelled'
  WHERE status = 'active'
    AND started_at < NOW() - INTERVAL '20 minutes';
  
  RETURN deleted_count;
END;
$$ LANGUAGE plpgsql;

-- Generate invite code
CREATE OR REPLACE FUNCTION generate_invite_code()
RETURNS VARCHAR(20) AS $$
DECLARE
  chars TEXT := 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
  result VARCHAR(20) := '';
  i INTEGER;
BEGIN
  FOR i IN 1..8 LOOP
    result := result || substr(chars, floor(random() * length(chars) + 1)::integer, 1);
  END LOOP;
  RETURN result;
END;
$$ LANGUAGE plpgsql;

-- Create competition invite
CREATE OR REPLACE FUNCTION create_competition_invite(
  p_competition_id UUID,
  p_user_id VARCHAR(255),
  p_max_uses INTEGER DEFAULT NULL,
  p_expires_in_days INTEGER DEFAULT 7
)
RETURNS competition_invites AS $$
DECLARE
  v_invite competition_invites;
  v_code VARCHAR(20);
BEGIN
  LOOP
    v_code := generate_invite_code();
    EXIT WHEN NOT EXISTS (SELECT 1 FROM competition_invites WHERE invite_code = v_code);
  END LOOP;
  
  INSERT INTO competition_invites (competition_id, invite_code, created_by, max_uses, expires_at)
  VALUES (
    p_competition_id, 
    v_code, 
    p_user_id, 
    p_max_uses,
    CASE WHEN p_expires_in_days IS NOT NULL 
         THEN NOW() + (p_expires_in_days || ' days')::interval 
         ELSE NULL END
  )
  RETURNING * INTO v_invite;
  
  RETURN v_invite;
END;
$$ LANGUAGE plpgsql;

-- Create arena invite
CREATE OR REPLACE FUNCTION create_arena_invite(
  p_arena_id UUID,
  p_user_id VARCHAR(255),
  p_role VARCHAR(50) DEFAULT 'participant',
  p_max_uses INTEGER DEFAULT NULL,
  p_expires_in_days INTEGER DEFAULT 7
)
RETURNS arena_invites AS $$
DECLARE
  v_invite arena_invites;
  v_code VARCHAR(20);
BEGIN
  LOOP
    v_code := generate_invite_code();
    EXIT WHEN NOT EXISTS (SELECT 1 FROM arena_invites WHERE invite_code = v_code);
  END LOOP;
  
  INSERT INTO arena_invites (arena_id, invite_code, created_by, role, max_uses, expires_at)
  VALUES (
    p_arena_id, 
    v_code, 
    p_user_id, 
    p_role,
    p_max_uses,
    CASE WHEN p_expires_in_days IS NOT NULL 
         THEN NOW() + (p_expires_in_days || ' days')::interval 
         ELSE NULL END
  )
  RETURNING * INTO v_invite;
  
  RETURN v_invite;
END;
$$ LANGUAGE plpgsql;

-- Create notification
CREATE OR REPLACE FUNCTION create_notification(
  p_user_id VARCHAR(255),
  p_type VARCHAR(50),
  p_title VARCHAR(255),
  p_message TEXT DEFAULT NULL,
  p_data JSONB DEFAULT '{}'
)
RETURNS UUID AS $$
DECLARE
  v_notification_id UUID;
BEGIN
  INSERT INTO notifications (user_id, type, title, message, data)
  VALUES (p_user_id, p_type, p_title, p_message, p_data)
  RETURNING id INTO v_notification_id;
  
  RETURN v_notification_id;
END;
$$ LANGUAGE plpgsql;

-- Get friend count
CREATE OR REPLACE FUNCTION get_friend_count(p_user_id VARCHAR(255))
RETURNS INTEGER AS $$
BEGIN
  RETURN (
    SELECT COUNT(*)
    FROM friendships
    WHERE (user_id = p_user_id OR friend_id = p_user_id)
    AND status = 'accepted'
  );
END;
$$ LANGUAGE plpgsql;

-- Update user presence
CREATE OR REPLACE FUNCTION update_presence(
  p_user_id VARCHAR(255),
  p_is_online BOOLEAN DEFAULT TRUE,
  p_activity VARCHAR(100) DEFAULT 'browsing',
  p_details JSONB DEFAULT '{}'
)
RETURNS VOID AS $$
BEGIN
  INSERT INTO user_presence (user_id, is_online, last_seen, current_activity, activity_details)
  VALUES (p_user_id, p_is_online, NOW(), p_activity, p_details)
  ON CONFLICT (user_id) DO UPDATE SET
    is_online = p_is_online,
    last_seen = NOW(),
    current_activity = p_activity,
    activity_details = p_details;
END;
$$ LANGUAGE plpgsql;

-- =============================================
-- SECTION 6: TRIGGERS
-- =============================================

-- Auto-generate invite code for private competitions
CREATE OR REPLACE FUNCTION generate_competition_invite_code()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.is_public = FALSE AND NEW.invite_code IS NULL THEN
    NEW.invite_code := UPPER(ENCODE(GEN_RANDOM_BYTES(6), 'hex'));
  END IF;
  
  IF NEW.is_public = TRUE THEN
    NEW.invite_code := NULL;
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trigger_competition_invite_code ON competitions;
CREATE TRIGGER trigger_competition_invite_code
  BEFORE INSERT OR UPDATE ON competitions
  FOR EACH ROW
  EXECUTE FUNCTION generate_competition_invite_code();

-- =============================================
-- SECTION 7: ROW LEVEL SECURITY (RLS)
-- =============================================

-- Enable RLS on all application tables
ALTER TABLE competitions ENABLE ROW LEVEL SECURITY;
ALTER TABLE test_cases ENABLE ROW LEVEL SECURITY;
ALTER TABLE submissions ENABLE ROW LEVEL SECURITY;
ALTER TABLE test_results ENABLE ROW LEVEL SECURITY;
ALTER TABLE judges ENABLE ROW LEVEL SECURITY;
ALTER TABLE prizes ENABLE ROW LEVEL SECURITY;
ALTER TABLE competition_templates ENABLE ROW LEVEL SECURITY;
ALTER TABLE arenas ENABLE ROW LEVEL SECURITY;
ALTER TABLE arena_participants ENABLE ROW LEVEL SECURITY;
ALTER TABLE arena_submissions ENABLE ROW LEVEL SECURITY;
ALTER TABLE arena_scores ENABLE ROW LEVEL SECURITY;
ALTER TABLE duel_challenges ENABLE ROW LEVEL SECURITY;
ALTER TABLE duel_queue ENABLE ROW LEVEL SECURITY;
ALTER TABLE duels ENABLE ROW LEVEL SECURITY;
ALTER TABLE duel_submissions ENABLE ROW LEVEL SECURITY;
ALTER TABLE duel_challenges_sent ENABLE ROW LEVEL SECURITY;
ALTER TABLE daily_challenges ENABLE ROW LEVEL SECURITY;
ALTER TABLE daily_submissions ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_streaks ENABLE ROW LEVEL SECURITY;
ALTER TABLE achievements ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_achievements ENABLE ROW LEVEL SECURITY;
ALTER TABLE spectate_sessions ENABLE ROW LEVEL SECURITY;
ALTER TABLE spectators ENABLE ROW LEVEL SECURITY;
ALTER TABLE spectate_emotes ENABLE ROW LEVEL SECURITY;
ALTER TABLE spectate_chat ENABLE ROW LEVEL SECURITY;
ALTER TABLE friendships ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_presence ENABLE ROW LEVEL SECURITY;
ALTER TABLE notifications ENABLE ROW LEVEL SECURITY;
ALTER TABLE notification_preferences ENABLE ROW LEVEL SECURITY;
ALTER TABLE tutorial_lessons ENABLE ROW LEVEL SECURITY;
ALTER TABLE tutorial_progress ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE usage_tracking ENABLE ROW LEVEL SECURITY;
ALTER TABLE payment_history ENABLE ROW LEVEL SECURITY;

-- Competition policies
CREATE POLICY "Anyone can view public competitions" ON competitions FOR SELECT USING (is_public = TRUE);
CREATE POLICY "Creators can view their competitions" ON competitions FOR SELECT USING (creator_id = current_user_id());
CREATE POLICY "Creators can manage their competitions" ON competitions FOR ALL USING (creator_id = current_user_id());

-- Test cases policies
CREATE POLICY "Users can view non-hidden test cases" ON test_cases FOR SELECT USING (is_hidden = FALSE);
CREATE POLICY "Competition creators can view all test cases" ON test_cases FOR SELECT USING (
  competition_id IN (SELECT id FROM competitions WHERE creator_id = current_user_id())
);

-- Submissions policies
CREATE POLICY "Users can view their own submissions" ON submissions FOR SELECT USING (user_id = current_user_id());
CREATE POLICY "Users can create submissions" ON submissions FOR INSERT WITH CHECK (user_id = current_user_id());

-- Template policies
CREATE POLICY "Users can view own and public templates" ON competition_templates
  FOR SELECT USING (creator_id = current_user_id() OR is_public = TRUE);
CREATE POLICY "Users can create templates" ON competition_templates
  FOR INSERT WITH CHECK (creator_id = current_user_id());
CREATE POLICY "Users can update own templates" ON competition_templates
  FOR UPDATE USING (creator_id = current_user_id());
CREATE POLICY "Users can delete own templates" ON competition_templates
  FOR DELETE USING (creator_id = current_user_id());

-- Duel policies
CREATE POLICY "Anyone can view duel challenges" ON duel_challenges FOR SELECT USING (true);
CREATE POLICY "Users can view queue" ON duel_queue FOR SELECT USING (true);
CREATE POLICY "Users can manage own queue entry" ON duel_queue FOR ALL USING (user_id = current_user_id());
CREATE POLICY "Users can view duels they're in" ON duels FOR SELECT 
  USING (player1_id = current_user_id() OR player2_id = current_user_id() OR player2_is_bot = true);
CREATE POLICY "Users can view their duel submissions" ON duel_submissions FOR SELECT
  USING (user_id = current_user_id());
CREATE POLICY "Users can create duel submissions" ON duel_submissions FOR INSERT
  WITH CHECK (user_id = current_user_id());
CREATE POLICY "Users can view their challenges" ON duel_challenges_sent FOR SELECT
  USING (challenger_id = current_user_id() OR challenged_id = current_user_id());
CREATE POLICY "Users can send challenges" ON duel_challenges_sent FOR INSERT
  WITH CHECK (challenger_id = current_user_id());
CREATE POLICY "Challenged users can respond" ON duel_challenges_sent FOR UPDATE
  USING (challenged_id = current_user_id());

-- Daily challenges policies
CREATE POLICY "Anyone can view daily challenges" ON daily_challenges FOR SELECT USING (true);
CREATE POLICY "Users can view all daily submissions" ON daily_submissions FOR SELECT USING (true);
CREATE POLICY "Users can submit their own" ON daily_submissions FOR INSERT WITH CHECK (true);
CREATE POLICY "Users can view their streaks" ON user_streaks FOR SELECT USING (true);
CREATE POLICY "System can manage streaks" ON user_streaks FOR ALL USING (true);

-- Achievement policies
CREATE POLICY "Anyone can view achievements" ON achievements FOR SELECT USING (true);
CREATE POLICY "Users can view their achievements" ON user_achievements FOR SELECT USING (true);
CREATE POLICY "System can manage user achievements" ON user_achievements FOR ALL USING (true);

-- Spectating policies
CREATE POLICY "Anyone can view live sessions" ON spectate_sessions FOR SELECT USING (true);
CREATE POLICY "Anyone can view spectators" ON spectators FOR SELECT USING (true);
CREATE POLICY "Users can join as spectator" ON spectators FOR INSERT WITH CHECK (true);
CREATE POLICY "Anyone can send emotes" ON spectate_emotes FOR INSERT WITH CHECK (true);
CREATE POLICY "Anyone can view emotes" ON spectate_emotes FOR SELECT USING (true);
CREATE POLICY "Anyone can chat" ON spectate_chat FOR INSERT WITH CHECK (true);
CREATE POLICY "Anyone can view chat" ON spectate_chat FOR SELECT USING (true);

-- Social policies
CREATE POLICY "Users can see their own friendships" ON friendships FOR SELECT USING (true);
CREATE POLICY "Users can create friend requests" ON friendships FOR INSERT WITH CHECK (true);
CREATE POLICY "Users can update their friendships" ON friendships FOR UPDATE USING (true);
CREATE POLICY "Users can delete their friendships" ON friendships FOR DELETE USING (true);
CREATE POLICY "Anyone can see online status" ON user_presence FOR SELECT USING (true);
CREATE POLICY "Users can update their presence" ON user_presence FOR ALL USING (true);

-- Notification policies
CREATE POLICY "Users see own notifications" ON notifications FOR SELECT USING (true);
CREATE POLICY "System can create notifications" ON notifications FOR INSERT WITH CHECK (true);
CREATE POLICY "Users can update own notifications" ON notifications FOR UPDATE USING (true);
CREATE POLICY "Users manage own preferences" ON notification_preferences FOR ALL USING (true);

-- Tutorial policies
CREATE POLICY "Anyone can view tutorials" ON tutorial_lessons FOR SELECT USING (true);
CREATE POLICY "Users track own progress" ON tutorial_progress FOR ALL USING (true);

-- Usage policies
CREATE POLICY "Users can view own usage" ON usage_tracking FOR SELECT USING (user_id = current_user_id());
CREATE POLICY "System can insert/update usage" ON usage_tracking FOR ALL USING (true);
CREATE POLICY "Users can view own payments" ON payment_history FOR SELECT USING (user_id = current_user_id());

-- =============================================
-- SECTION 8: SEED DATA
-- =============================================

-- Seed achievements
INSERT INTO achievements (slug, name, description, category, icon, rarity, xp_reward, requirement_type, requirement_value) VALUES
('first_submission', 'First Steps', 'Submit your first solution', 'competition', '', 'common', 25, 'count', 1),
('ten_submissions', 'Getting Warmed Up', 'Submit 10 solutions', 'competition', '', 'common', 50, 'count', 10),
('hundred_submissions', 'Centurion', 'Submit 100 solutions', 'competition', '', 'rare', 200, 'count', 100),
('first_win', 'Victor', 'Win your first competition', 'competition', '', 'uncommon', 100, 'count', 1),
('five_wins', 'Champion', 'Win 5 competitions', 'competition', '', 'rare', 300, 'count', 5),
('perfect_score', 'Perfectionist', 'Get 100% score on a competition', 'competition', '', 'uncommon', 150, 'special', 100),
('first_duel', 'Challenger', 'Complete your first duel', 'duel', '', 'common', 25, 'count', 1),
('duel_winner', 'Duelist', 'Win your first duel', 'duel', '', 'common', 50, 'count', 1),
('ten_duel_wins', 'Gladiator', 'Win 10 duels', 'duel', '', 'uncommon', 150, 'count', 10),
('fifty_duel_wins', 'Arena Master', 'Win 50 duels', 'duel', '', 'rare', 400, 'count', 50),
('duel_streak_5', 'Hot Streak', 'Win 5 duels in a row', 'duel', '', 'rare', 250, 'streak', 5),
('duel_streak_10', 'Unstoppable', 'Win 10 duels in a row', 'duel', '', 'epic', 500, 'streak', 10),
('speed_demon', 'Speed Demon', 'Win a duel in under 60 seconds', 'duel', '', 'rare', 300, 'speed', 60),
('streak_3', 'Consistent', 'Complete 3 daily challenges in a row', 'streak', '', 'common', 50, 'streak', 3),
('streak_7', 'Week Warrior', 'Complete 7 daily challenges in a row', 'streak', '', 'uncommon', 150, 'streak', 7),
('streak_30', 'Month Master', 'Complete 30 daily challenges in a row', 'streak', '', 'rare', 500, 'streak', 30),
('streak_100', 'Century Streak', 'Complete 100 daily challenges in a row', 'streak', '', 'legendary', 2000, 'streak', 100),
('daily_solver', 'Daily Devotee', 'Complete 50 total daily challenges', 'streak', '', 'uncommon', 200, 'count', 50),
('rating_1200', 'Rising Star', 'Reach 1200 skill rating', 'skill', '', 'common', 75, 'rating', 1200),
('rating_1500', 'Skilled Coder', 'Reach 1500 skill rating', 'skill', '', 'uncommon', 150, 'rating', 1500),
('rating_1800', 'Expert', 'Reach 1800 skill rating', 'skill', '', 'rare', 300, 'rating', 1800),
('rating_2000', 'Master', 'Reach 2000 skill rating', 'skill', '', 'epic', 500, 'rating', 2000),
('rating_2200', 'Grandmaster', 'Reach 2200 skill rating', 'skill', '', 'legendary', 1000, 'rating', 2200),
('join_org', 'Team Player', 'Join an organization', 'social', '', 'common', 25, 'count', 1),
('create_org', 'Leader', 'Create an organization', 'social', '', 'uncommon', 100, 'count', 1),
('challenge_friend', 'Friendly Fire', 'Challenge a friend to a duel', 'social', '', 'common', 30, 'count', 1),
('spectate_match', 'Spectator', 'Watch a live duel', 'social', '', 'common', 20, 'count', 1),
('send_emote', 'Cheerleader', 'Send 10 emotes while spectating', 'social', '', 'common', 25, 'count', 10),
('night_owl', 'Night Owl', 'Submit a solution between midnight and 4am', 'special', '', 'uncommon', 75, 'special', 0),
('early_bird', 'Early Bird', 'Submit a solution between 5am and 7am', 'special', '', 'uncommon', 75, 'special', 0),
('polyglot', 'Polyglot', 'Submit solutions in 5 different languages', 'special', '', 'rare', 200, 'count', 5),
('comeback_kid', 'Comeback Kid', 'Win after being behind', 'special', '', 'rare', 250, 'special', 0),
('speed_solver', 'Lightning Fast', 'Solve 10 problems in under 2 minutes each', 'special', '', 'epic', 400, 'count', 10)
ON CONFLICT (slug) DO NOTHING;

-- Seed duel challenges
INSERT INTO duel_challenges (title, description, difficulty, category, time_limit_seconds, test_cases) VALUES
('Two Sum', 'Given an array of integers and a target sum, return indices of two numbers that add up to the target.', 'easy', 'arrays', 300, 
 '[{"input": "[2, 7, 11, 15]\n9", "expected_output": "[0, 1]", "points": 25}, {"input": "[3, 2, 4]\n6", "expected_output": "[1, 2]", "points": 25}, {"input": "[3, 3]\n6", "expected_output": "[0, 1]", "points": 25}, {"input": "[1, 5, 3, 7, 8, 2]\n10", "expected_output": "[1, 4]", "points": 25}]'),
('Reverse String', 'Write a function that reverses a string. The input is given as a string.', 'easy', 'strings', 180,
 '[{"input": "hello", "expected_output": "olleh", "points": 25}, {"input": "world", "expected_output": "dlrow", "points": 25}, {"input": "a", "expected_output": "a", "points": 25}, {"input": "ab", "expected_output": "ba", "points": 25}]'),
('FizzBuzz', 'Print numbers 1 to N. For multiples of 3 print Fizz, for 5 print Buzz, for both print FizzBuzz.', 'easy', 'basics', 180,
 '[{"input": "5", "expected_output": "1\n2\nFizz\n4\nBuzz", "points": 25}, {"input": "15", "expected_output": "1\n2\nFizz\n4\nBuzz\nFizz\n7\n8\nFizz\nBuzz\n11\nFizz\n13\n14\nFizzBuzz", "points": 25}, {"input": "3", "expected_output": "1\n2\nFizz", "points": 25}, {"input": "1", "expected_output": "1", "points": 25}]'),
('Valid Parentheses', 'Given a string containing just parentheses, determine if the input string is valid.', 'medium', 'strings', 300,
 '[{"input": "()", "expected_output": "true", "points": 25}, {"input": "()[]{}", "expected_output": "true", "points": 25}, {"input": "(]", "expected_output": "false", "points": 25}, {"input": "([)]", "expected_output": "false", "points": 25}]'),
('Maximum Subarray', 'Find the contiguous subarray with the largest sum and return that sum.', 'medium', 'arrays', 300,
 '[{"input": "[-2,1,-3,4,-1,2,1,-5,4]", "expected_output": "6", "points": 25}, {"input": "[1]", "expected_output": "1", "points": 25}, {"input": "[5,4,-1,7,8]", "expected_output": "23", "points": 25}, {"input": "[-1,-2,-3]", "expected_output": "-1", "points": 25}]'),
('Longest Substring', 'Find length of longest substring without repeating characters.', 'hard', 'strings', 420,
 '[{"input": "abcabcbb", "expected_output": "3", "points": 25}, {"input": "bbbbb", "expected_output": "1", "points": 25}, {"input": "pwwkew", "expected_output": "3", "points": 25}, {"input": "", "expected_output": "0", "points": 25}]')
ON CONFLICT DO NOTHING;

-- Seed code templates
INSERT INTO code_templates (user_id, name, description, code, language, is_public, category, tags, is_starter)
VALUES
('system', 'Python - Fast I/O', 'Optimized input/output for competitive programming', 
'import sys
input = sys.stdin.readline

def solve():
    n = int(input())
    arr = list(map(int, input().split()))
    # Your solution here
    print(result)

solve()', 'python', TRUE, 'competitive', ARRAY['io', 'optimization'], TRUE),
('system', 'Python - BFS Template', 'Breadth-first search template',
'from collections import deque

def bfs(graph, start):
    visited = set([start])
    queue = deque([start])
    
    while queue:
        node = queue.popleft()
        for neighbor in graph[node]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)
    
    return visited', 'python', TRUE, 'algorithms', ARRAY['bfs', 'graph'], TRUE),
('system', 'JavaScript - Fast I/O', 'Optimized input for competitive programming',
'const readline = require("readline");
const rl = readline.createInterface({ input: process.stdin });
const lines = [];

rl.on("line", (line) => lines.push(line));
rl.on("close", () => {
    let idx = 0;
    const read = () => lines[idx++];
    
    // Your solution here
    const n = parseInt(read());
    const arr = read().split(" ").map(Number);
    
    console.log(result);
});', 'javascript', TRUE, 'competitive', ARRAY['io', 'optimization'], TRUE)
ON CONFLICT DO NOTHING;

-- =============================================
-- END OF SCHEMA
-- =============================================

COMMIT;
